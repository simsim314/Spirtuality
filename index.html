<!DOCTYPE html>
<html>
<head>
<title>BigInt Timeline OOP (Universe Epoch, Cyclical Date) - Dynamic Now</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    /* Flexbox setup for vertical layout */
    display: flex;
    flex-direction: column;
    /* Centers direct children (like the title) HORIZONTALLY because flex-direction is column */
    align-items: center;
    position: relative; /* Needed for absolute positioning of canvas/info */
    height: 100vh; /* Ensure body takes full viewport height */
  }

  canvas {
    display: block;
    background-color: #f0f0f0;
    cursor: crosshair;
    /* Position canvas absolutely to cover the entire body */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Place canvas behind other elements */
  }

  .title-banner {
    /* This element is a flex item and will be centered by body's align-items */
    margin-top: 10px; /* Space above the title */
    font-size: 20px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px 16px;
    border-radius: 8px;
    user-select: none; /* Prevent text selection */
    z-index: 2; /* Place title above the canvas */
  }

  .info {
    /* Position info box absolutely, independent of flex centering */
    position: absolute;
    top: 60px; /* Position below where the title sits */
    left: 10px; /* Position in the top-left corner */
    background: rgba(255, 255, 255, 0.8);
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 12px;
    user-select: text; /* Allow text selection */
    z-index: 2; /* Place info box above the canvas */
  }

  .info span {
    display: block; /* Stack info lines vertically */
  }
</style>

</head>


<body>

  <!-- ✅ ADD THIS DIV FOR THE TITLE -->
  <div class="title-banner">ABB Timeline — After Big Bang Time Explorer</div>

<div class="info" id="info-display">
  <span>Start: <span id="info-start"></span></span>
  <span>End: <span id="info-end"></span></span>
  <span>Cursor: <span id="info-cursor"></span></span>
  <span>Now: <span id="info-now"></span></span>
</div>

<canvas id="timelineCanvas"></canvas>
<script>
    // --- BigInt Constants and Time Scale ---
    const SCALING_FACTOR = 10000n;
    const CUSTOM_TIME_MIN_BI = 0n;
    const YEARS_AGO_EPOCH = 13800000000n; // Approx. age for historical calculations
    const MAX_YEARS_FROM_EPOCH = 150000000000n;
    const CUSTOM_TIME_MAX_BI = MAX_YEARS_FROM_EPOCH * SCALING_FACTOR;
    // REMOVED: const NOW_TBI = YEARS_AGO_EPOCH * SCALING_FACTOR; // No longer using fixed NOW_TBI for dynamic 'Now'

    const MS_PER_SECOND_BI = 1000n;
    const SECONDS_PER_MINUTE_BI = 60n;
    const MINUTES_PER_HOUR_BI = 60n;
    const HOURS_PER_DAY_BI = 24n;
    const DAYS_PER_YEAR_APPROX_BI = 3652425n;
    const MS_PER_YEAR_BI = (MS_PER_SECOND_BI * SECONDS_PER_MINUTE_BI * MINUTES_PER_HOUR_BI * HOURS_PER_DAY_BI * DAYS_PER_YEAR_APPROX_BI) / 10000n;

    // --- Configuration & State ---
    const canvas = document.getElementById('timelineCanvas');
    const ctx = canvas.getContext('2d');
    const infoStartEl = document.getElementById('info-start');
    const infoEndEl = document.getElementById('info-end');
    const infoCursorEl = document.getElementById('info-cursor');
    const infoNowEl = document.getElementById('info-now');

    // --- BigInt Time Conversion Functions ---

    // ❗ CRITICAL dateToCustomBi: MUST correctly convert JS Date to the ABB timeline tBi
    function dateToCustomBi(date) {
        if (!date || isNaN(date.getTime())) {
            console.warn("Invalid date provided to dateToCustomBi, using current time.");
            try { date = new Date(); } catch { return YEARS_AGO_EPOCH * SCALING_FACTOR; } // Fallback if new Date fails
        }

        try {
            // Base reference: The fixed point YEARS_AGO_EPOCH corresponds roughly to 'now'.
            const referenceTbi = YEARS_AGO_EPOCH * SCALING_FACTOR;
            const referenceDate = new Date(); // Use current date as the reference point matching referenceTbi

            const targetMs = BigInt(date.getTime());
            const referenceMs = BigInt(referenceDate.getTime());

            // Calculate the difference in milliseconds between the target date and the reference date ('now')
            const msDifference = targetMs - referenceMs;

            // Convert this millisecond difference into a tBi difference
            let tBiDifference = 0n;
            if (MS_PER_YEAR_BI > 0n) {
                // Scale the ms difference by SCALING_FACTOR and divide by MS_PER_YEAR_BI
                tBiDifference = (msDifference * SCALING_FACTOR) / MS_PER_YEAR_BI;
            }

            // Calculate the final tBi by adding the difference to the reference Tbi
            let t = referenceTbi + tBiDifference;

            // Clamp to valid range
            t = t < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : t;
            t = t > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : t;
            return t;
        } catch (e) {
            console.error("Error in dateToCustomBi:", e);
            // Fallback to approximate 'Now' if calculation fails
            return YEARS_AGO_EPOCH * SCALING_FACTOR;
        }
    }


    // This customBiToDate seems to be attempting Gregorian conversion.
    // Let's keep the simpler getDateTimeStringFromTbi for display purposes,
    // as converting far-future/past tBi back to Gregorian is problematic.
    function customBiToDate(tBi) {
        if (typeof tBi !== 'bigint') return new Date(NaN);

        try {
             // Base reference: The fixed point YEARS_AGO_EPOCH corresponds roughly to 'now'.
             const referenceTbi = YEARS_AGO_EPOCH * SCALING_FACTOR;
             const referenceDate = new Date(); // Use current date as the reference point matching referenceTbi

             // Calculate tBi difference from the reference 'now'
             const tBiDifference = tBi - referenceTbi;

             // Convert tBi difference to millisecond difference
             let msDifference = 0n;
             if (SCALING_FACTOR > 0n) {
                msDifference = (tBiDifference * MS_PER_YEAR_BI) / SCALING_FACTOR;
             }

             // Add ms difference to current time's ms
             const referenceMs = BigInt(referenceDate.getTime());
             const targetMs = referenceMs + msDifference;

             // Check if representable by JS Date (Number)
             const MAX_SAFE_MS_NUM = 8.64e15; // Max ms for JS Date
             const MIN_SAFE_MS_NUM = -8.64e15; // Min ms for JS Date
             if (targetMs > BigInt(MAX_SAFE_MS_NUM) || targetMs < BigInt(MIN_SAFE_MS_NUM)) {
                return new Date(NaN); // Outside standard JS Date range
             }

            const targetMsNum = Number(targetMs);
            const calculatedDate = new Date(targetMsNum);

            // Final check if the resulting Date is valid
            if (isNaN(calculatedDate.getTime())) { return new Date(NaN); }
            return calculatedDate;

        } catch (e) {
            console.error("Error in customBiToDate:", e);
            return new Date(NaN);
        }
    }


    function getAstronomicalYear(tBi) { /* ... as before ... */
         if (typeof tBi !== 'bigint' || tBi < 0n) { return null; } if (tBi === 0n) return 1n; return tBi / SCALING_FACTOR + 1n;
    }

    // Using the surrogate year approach for cyclical time display
    function getDateTimeStringFromTbi(tBi) {
        if (typeof tBi !== 'bigint') return "Invalid";

        const astronomicalYearBi = getAstronomicalYear(tBi);
        if (astronomicalYearBi === null) return "Invalid Year";
        const displayYearStr = astronomicalYearBi.toLocaleString(); // Just the ABB year number

        // Calculate fractional part for time of year
        const fractionalUnitsBi = tBi % SCALING_FACTOR; // Units within the current year (0 to SCALING_FACTOR-1)
        let msFractionalBi = 0n;
        if (SCALING_FACTOR > 0n && MS_PER_YEAR_BI > 0n) {
             // Calculate how many milliseconds into the year this fraction represents
             msFractionalBi = (fractionalUnitsBi * MS_PER_YEAR_BI) / SCALING_FACTOR;
        } else {
             return `${displayYearStr}-??-?? ??:??:?? ABB (Calc Error)`; // Handle potential division by zero
        }


        // Use a surrogate Gregorian year (like 2000 or 1970) as a base
        // to leverage Date object's handling of month/day/time from milliseconds.
        // We only care about the *time within the year*, not the absolute year.
        // Using UTC to avoid timezone offsets. A leap year base helps slightly.
        const baseYearStartMs = Date.UTC(2000, 0, 1, 0, 0, 0, 0); // Start of Jan 1st, 2000 UTC

        const msFractionalNum = Number(msFractionalBi);

        if (!Number.isSafeInteger(msFractionalNum)) {
            return `${displayYearStr}-??-?? ??:??:?? ABB (Unsafe Fraction)`;
        }

        // Create a representative date by adding the fractional milliseconds to the base date
        const representativeDate = new Date(baseYearStartMs + msFractionalNum);

        if (isNaN(representativeDate.getTime())) {
            return `${displayYearStr}-??-?? ??:??:?? ABB (Date Error)`;
        }

        // Extract cyclical time components (month, day, time) from the representative date
        const month = (representativeDate.getUTCMonth() + 1).toString().padStart(2, '0');
        const day = representativeDate.getUTCDate().toString().padStart(2, '0'); // Day of month
        const hours = representativeDate.getUTCHours().toString().padStart(2, '0');
        const minutes = representativeDate.getUTCMinutes().toString().padStart(2, '0');
        const seconds = representativeDate.getUTCSeconds().toString().padStart(2, '0');

        // Combine the absolute ABB year with the cyclical time
        return `${displayYearStr}-${month}-${day} ${hours}:${minutes}:${seconds} ABB`;
    }


    function formatTimeBiLabel(tBi) { /* ... as before ... */
         if (typeof tBi !== 'bigint') return "Invalid"; let absValue = tBi < 0n ? -tBi : tBi; const sign = tBi < 0n ? "-" : ""; let intPart = absValue / SCALING_FACTOR; let fracPart = absValue % SCALING_FACTOR; let intPartStr = intPart.toLocaleString();
         if (fracPart === 0n) { return sign + intPartStr; } else { let fracPartStr = fracPart.toString().padStart(SCALING_FACTOR.toString().length -1, '0'); fracPartStr = fracPartStr.replace(/0+$/, ''); return sign + intPartStr + (fracPartStr.length > 0 ? "." + fracPartStr : ""); }
    }
    function timeBiToX(tBi) { /* ... as before ... */
        const spanBI = interval.end - interval.start; if (spanBI <= 0n) return ctx.canvas.width * 0.1; let timeVal = typeof tBi === 'bigint' ? tBi : interval.start; const clamped_t = timeVal < interval.start ? interval.start : (timeVal > interval.end ? interval.end : timeVal); const numerator = Number(clamped_t - interval.start); const denominator = Number(spanBI); if (denominator === 0) return ctx.canvas.width * 0.1; const ratio = numerator / denominator; const rulerMargin = ctx.canvas.width * 0.1; const rulerWidth = ctx.canvas.width * 0.8; const xPos = rulerMargin + rulerWidth * ratio; return isFinite(xPos) ? xPos : rulerMargin;
    }
    function xToTimeBi(x) { /* ... as before ... */
        const canvasWidth = ctx.canvas.width; const rulerMargin = canvasWidth * 0.1; const rulerWidth = canvasWidth * 0.8; const rulerEnd = rulerMargin + rulerWidth; const clamped_x = Math.max(rulerMargin, Math.min(rulerEnd, x)); const ratio = (clamped_x - rulerMargin) / rulerWidth; if (!isFinite(ratio)) return interval.start; const spanBI = interval.end - interval.start; const offsetNum = Number(spanBI) * ratio; const offsetBI = BigInt(Math.round(offsetNum)); let calculatedTimeBI = interval.start + offsetBI; calculatedTimeBI = calculatedTimeBI < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : calculatedTimeBI; calculatedTimeBI = calculatedTimeBI > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : calculatedTimeBI; return calculatedTimeBI;
    }
     function calculateNiceTickSpacingBi(spanBi) { /* ... as before ... */
        if (spanBi <= 0n) return { major: 1n * SCALING_FACTOR, minor: (1n * SCALING_FACTOR) / 10n || 1n }; const targetMajorTicks = 10.0; const idealMajorSpacingNum = Number(spanBi) / targetMajorTicks; if (idealMajorSpacingNum <= 0 || !isFinite(idealMajorSpacingNum)) { let fallbackMajor = spanBi / 5n || 1n; fallbackMajor = fallbackMajor > 0n ? fallbackMajor : 1n; let fallbackMinor = fallbackMajor / 10n || 1n; fallbackMinor = fallbackMinor > 0n ? fallbackMinor : 1n; return { major: fallbackMajor, minor: fallbackMinor }; } const magnitudeNum = Math.pow(10, Math.floor(Math.log10(idealMajorSpacingNum))); const residual = idealMajorSpacingNum / magnitudeNum; let niceMultiplierNum; if (residual <= 1.5) niceMultiplierNum = 1; else if (residual <= 3.5) niceMultiplierNum = 2; else if (residual <= 7.5) niceMultiplierNum = 5; else niceMultiplierNum = 10; let majorSpacingBi = BigInt(Math.max(1, Math.round(niceMultiplierNum * magnitudeNum))); majorSpacingBi = majorSpacingBi > 0n ? majorSpacingBi : 1n; let minorSpacingBi = majorSpacingBi / 10n; minorSpacingBi = minorSpacingBi > 0n ? minorSpacingBi : 1n; return { major: majorSpacingBi, minor: minorSpacingBi };
    }

    // --- Timeline Element Classes ---
    class TimelineElement { /* ... as before ... */
        constructor(label, startTbi, endTbi, color) { this.label = label; this.startTbi = startTbi; this.endTbi = endTbi; this.color = color || '#888888'; this.height = 8; }
        isVisible(interval) { return this.endTbi >= interval.start && this.startTbi <= interval.end; }
        draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) { if (!this.isVisible(interval)) { return; } const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); if (endX > startX && endX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; if (drawWidth > 0) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center'; const labelX = drawStartX + drawWidth / 2; if (drawWidth > ctx.measureText(this.label).width * 0.8) { ctx.fillText(this.label, labelX, yPos - 2); } else if (startX >= rulerMargin && startX <= rulerEnd) { ctx.fillText(this.label, startX + 3, yPos - 2); } } } else if (endX === startX && startX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(startX, yPos); ctx.lineTo(startX - 3, yPos + this.height); ctx.lineTo(startX + 3, yPos + this.height); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(this.label, startX, yPos - 2); } }
    }
    class SunElement extends TimelineElement { /* ... as before ... */
        constructor(startYearABB, endYearABB) { const startTbi = startYearABB * SCALING_FACTOR; const endTbi = endYearABB * SCALING_FACTOR; super('☉ Sun (Main Sequence)', startTbi, endTbi, 'rgba(255, 165, 0, 0.7)'); this.height = 10; }
        draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) { if (!this.isVisible(interval)) return; const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); if (endX > startX && endX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; if (drawWidth > 0) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); ctx.fillStyle = '#cc8400'; ctx.font = '9px sans-serif'; const labelOffset = this.height + 2; if (startX >= rulerMargin - 5 && startX <= rulerEnd + 5) { ctx.textAlign = 'center'; ctx.fillText('Start', startX, yPos - 2); } if (endX >= rulerMargin - 5 && endX <= rulerEnd + 5) { ctx.textAlign = 'center'; ctx.fillText('End', endX, yPos - 2); } ctx.fillStyle = '#000'; ctx.textAlign = 'center'; const labelX = drawStartX + drawWidth / 2; if (drawWidth > ctx.measureText(this.label).width * 0.8) { ctx.fillText(this.label, labelX, yPos + this.height + 10); } } } }
    }
    class DinosaurElement extends TimelineElement { /* ... as before ... */
         constructor(startYearsAgo, endYearsAgo) { const startYearABB = YEARS_AGO_EPOCH - startYearsAgo; const endYearABB = YEARS_AGO_EPOCH - endYearsAgo; const startTbi = startYearABB * SCALING_FACTOR; const endTbi = endYearABB * SCALING_FACTOR; super('Dinosaurs (Mesozoic Era)', startTbi, endTbi, 'rgba(0, 128, 0, 0.7)'); this.height = 6; }
    }
    class HumanElement extends TimelineElement { /* ... as before ... */
         constructor(startYearsAgo) { const startYearABB = YEARS_AGO_EPOCH - startYearsAgo; const endYearABB = YEARS_AGO_EPOCH; /* Ends 'now' */ const startTbi = startYearABB * SCALING_FACTOR; /* Dynamic end below */ super('Humans (Homo Sapiens)', startTbi, 0n /* Placeholder end */, 'rgba(0, 0, 255, 0.7)'); this.height = 4; } // EndTbi will be set dynamically
         draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) {
              this.endTbi = dateToCustomBi(new Date()); // ✅ Set dynamic end time here!
              if (!this.isVisible(interval)) return;
              const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); // Use dynamic endX
              if (endX >= rulerMargin && startX <= rulerEnd) { const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; ctx.fillStyle = this.color; if (drawWidth >= 1) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); } else if (startX >= rulerMargin && startX <= rulerEnd) { ctx.lineWidth = 1.5; ctx.strokeStyle = this.color; ctx.beginPath(); ctx.moveTo(startX, yPos - 2); ctx.lineTo(startX, yPos + this.height + 2); ctx.stroke(); } if (startX >= rulerMargin - 5 && startX <= rulerEnd + 5) { ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'left'; ctx.fillText(this.label, startX + 4, yPos + this.height / 2 + 3); } }
         }
    }
    class TimelineManager { /* ... as before ... */
        constructor(rulerY, verticalSpacing) { this.elements = []; this.rulerY = rulerY; this.verticalSpacing = verticalSpacing; }
        addElement(element) { if (element instanceof TimelineElement) { this.elements.push(element); } else { console.warn("Attempted to add non-TimelineElement object:", element); } }
        drawElements(ctx, interval, timeBiToX, rulerMargin, rulerEnd) { this.elements.forEach((element, index) => { const yPos = this.rulerY - (index + 1) * this.verticalSpacing - element.height; try { element.draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd); } catch (e) { console.error("Error drawing element:", element.label, e); } }); }
    }


    // --- Initial State Setup ---
    // ✅ 1. Calculate initial 'Now' dynamically
    const initialNowBi = dateToCustomBi(new Date());
    const initialSpanYears = 100n; // Initial view span
    const initialSpanBI = initialSpanYears * SCALING_FACTOR;

    // ✅ 2. Use dynamic initialNowBi for centering the view
    let interval = {
        start: initialNowBi - initialSpanBI / 2n,
        end:   initialNowBi + initialSpanBI / 2n,
        now:   initialNowBi, // Set initial 'now' state
        cursor: -1n
    };
    // Clamp initial interval...
    interval.start = interval.start < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : interval.start;
    interval.end = interval.end > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : interval.end;
    // Ensure start < end after clamping
    if (interval.start >= interval.end) {
        interval.start = interval.end - initialSpanBI;
        interval.start = interval.start < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : interval.start;
        if (interval.start >= interval.end) {
             interval.end = interval.start + initialSpanBI;
             interval.end = interval.end > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : interval.end;
         }
    }
     // Ensure initial 'now' is within the calculated initial view
    interval.now = interval.now < interval.start ? interval.start : interval.now;
    interval.now = interval.now > interval.end ? interval.end : interval.now;


    let pos = { x: 0, y: 0 };

    // --- Create and Populate Timeline Manager ---
    const SUN_START_YEAR_ABB = YEARS_AGO_EPOCH - 4600000000n;
    const SUN_END_YEAR_ABB = YEARS_AGO_EPOCH + 5000000000n;
    const DINO_START_YEARS_AGO = 245000000n;
    const DINO_END_YEARS_AGO = 66000000n;
    const HUMAN_START_YEARS_AGO = 300000n; // Homo Sapiens start

    const timelineManager = new TimelineManager(canvas.height * 0.5, 15); // Ruler Y, Spacing

    timelineManager.addElement(new SunElement(SUN_START_YEAR_ABB, SUN_END_YEAR_ABB));
    timelineManager.addElement(new DinosaurElement(DINO_START_YEARS_AGO, DINO_END_YEARS_AGO));
    timelineManager.addElement(new HumanElement(HUMAN_START_YEARS_AGO)); // End time is dynamic now


    // --- Drawing Function ---
    function drawRuler() {
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const rulerY = canvasHeight * 0.5;
        const rulerMargin = canvasWidth * 0.1;
        const rulerWidth = canvasWidth * 0.8;
        const rulerEnd = rulerMargin + rulerWidth;

        timelineManager.rulerY = rulerY; // Update manager's rulerY

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.lineWidth = 2; ctx.strokeStyle = '#333';
        ctx.beginPath(); ctx.moveTo(rulerMargin, rulerY); ctx.lineTo(rulerEnd, rulerY); ctx.stroke();

        // Calculate Ticks... (same logic)
        const spanBI = interval.end - interval.start; let currentMajorSpacingBi = 0n; let currentMinorSpacingBi = 0n;
        if (spanBI > 0n) { const spacing = calculateNiceTickSpacingBi(spanBI); currentMajorSpacingBi = spacing.major; currentMinorSpacingBi = spacing.minor; } else { currentMajorSpacingBi = 1n * SCALING_FACTOR; currentMinorSpacingBi = currentMajorSpacingBi / 10n || 1n; }

        // Draw Ticks & Labels... (same logic)
        if (currentMinorSpacingBi > 0n && currentMajorSpacingBi > 0n) {
            let remainder = interval.start % currentMinorSpacingBi; if (remainder < 0n) { remainder += currentMinorSpacingBi; } let firstTickTimeBi = interval.start - remainder + (remainder === 0n ? 0n : currentMinorSpacingBi); if (firstTickTimeBi < interval.start) { firstTickTimeBi += currentMinorSpacingBi; } ctx.lineWidth = 1; ctx.strokeStyle = '#666'; ctx.fillStyle = '#333'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            for (let tBi = firstTickTimeBi; tBi <= interval.end + currentMinorSpacingBi; tBi += currentMinorSpacingBi) {
                 if (tBi < interval.start - currentMinorSpacingBi) continue; const x = timeBiToX(tBi); if (x < rulerMargin - 10 || x > rulerEnd + 10) continue; let isMajorTick = false; try { isMajorTick = (tBi % currentMajorSpacingBi === 0n); } catch {} ctx.beginPath(); ctx.moveTo(x, rulerY - (isMajorTick ? 8 : 4)); ctx.lineTo(x, rulerY + (isMajorTick ? 8 : 4)); ctx.stroke(); if (isMajorTick) { if (x >= rulerMargin - 0.1 && x <= rulerEnd + 0.1) { const label = formatTimeBiLabel(tBi); ctx.fillText(label, x, rulerY + 20); } }
            }
        } else { console.warn("Final tick spacing invalid or zero span."); }

        // Draw Timeline Elements via Manager
        // ✅ HumanElement's endTbi is updated inside its draw method now
        timelineManager.drawElements(ctx, interval, timeBiToX, rulerMargin, rulerEnd);

        // --- Draw 'Now' Line ---
        // ✅ 3. Update interval.now dynamically EACH FRAME
        interval.now = dateToCustomBi(new Date());
        // Ensure 'Now' marker stays within visible bounds if view pans away
        const nowTbiClampedForDraw = interval.now < interval.start ? interval.start : (interval.now > interval.end ? interval.end : interval.now);

        if (interval.now >= interval.start && interval.now <= interval.end) { // Check if actual 'now' is in view range
            const nowX = timeBiToX(interval.now); // Use the actual 'now' for X position
            if (isFinite(nowX)) {
                ctx.lineWidth = 1.5; ctx.strokeStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(nowX, rulerY - 15); ctx.lineTo(nowX, rulerY + 15); ctx.stroke();
                ctx.fillStyle = '#ff0000'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('Now', nowX, rulerY - 18);
            }
        } else {
             // Optional: Indicate if 'Now' is off-screen? (Could add text or markers at edges)
        }


        // Draw Cursor Line... (same logic)
        if (interval.cursor >= CUSTOM_TIME_MIN_BI && interval.cursor >= interval.start && interval.cursor <= interval.end) {
            const cursorX = timeBiToX(interval.cursor);
            if (isFinite(cursorX)) { ctx.lineWidth = 1.5; ctx.strokeStyle = '#00cc00'; ctx.beginPath(); ctx.moveTo(cursorX, rulerY - 12); ctx.lineTo(cursorX, rulerY + 12); ctx.stroke(); ctx.fillStyle = '#00cc00'; ctx.beginPath(); ctx.moveTo(cursorX - 4, rulerY - 12); ctx.lineTo(cursorX + 4, rulerY - 12); ctx.lineTo(cursorX, rulerY - 18); ctx.closePath(); ctx.fill(); }
        }

        // Update Info Display...
        // ✅ Uses the dynamically updated interval.now from this frame
        infoStartEl.textContent = `${getDateTimeStringFromTbi(interval.start)} (t=${formatTimeBiLabel(interval.start)})`;
        infoEndEl.textContent = `${getDateTimeStringFromTbi(interval.end)} (t=${formatTimeBiLabel(interval.end)})`;
        infoCursorEl.textContent = interval.cursor < CUSTOM_TIME_MIN_BI ? 'N/A' : `${getDateTimeStringFromTbi(interval.cursor)} (t=${formatTimeBiLabel(interval.cursor)})`;
        // Display the dynamically calculated 'Now' value
        infoNowEl.textContent = `${getDateTimeStringFromTbi(interval.now)} (t=${formatTimeBiLabel(interval.now)})`;

    } // End drawRuler

    function redraw() { requestAnimationFrame(drawRuler); }

     // --- Event Handlers ---
     function handleResize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; redraw(); }
     function handleMouseMove(event) { pos.x = event.clientX; pos.y = event.clientY; }
     function handleMouseDown(event) { /* ... as before ... */
         if (event.button !== 0) return; pos.x = event.clientX; pos.y = event.clientY; const rulerY = canvas.height * 0.5; if (Math.abs(pos.y - rulerY) < 50) { interval.cursor = xToTimeBi(pos.x); console.log("Cursor set to tBi:", interval.cursor.toString(), " -> ", getDateTimeStringFromTbi(interval.cursor)); redraw(); } }
    function handleWheel(event) { /* ... as before ... */
        event.preventDefault(); const scrollDelta = event.deltaY; const zoomFactor = scrollDelta < 0 ? 0.80 : 1.20; const minSpanBi = 10n; const timeAtMouseBi = xToTimeBi(event.clientX); const currentSpanBi = interval.end - interval.start; const maxPossibleSpan = CUSTOM_TIME_MAX_BI - CUSTOM_TIME_MIN_BI; if (currentSpanBi <= minSpanBi && zoomFactor < 1) return; if (currentSpanBi >= maxPossibleSpan && zoomFactor > 1) return; let newSpanNum = Number(currentSpanBi) * zoomFactor; let newSpanBi = BigInt(Math.round(newSpanNum)); newSpanBi = newSpanBi > minSpanBi ? newSpanBi : minSpanBi; newSpanBi = newSpanBi > maxPossibleSpan ? maxPossibleSpan : newSpanBi; let ratio = 0.5; if (currentSpanBi > 0n) { const mouseOffsetNum = Number(timeAtMouseBi - interval.start); const currentSpanNum = Number(currentSpanBi); ratio = currentSpanNum === 0 ? 0.5 : mouseOffsetNum / currentSpanNum; ratio = Math.max(0, Math.min(1, ratio)); } const offsetNum = Number(newSpanBi) * ratio; const offsetBi = BigInt(Math.round(offsetNum)); let newStart = timeAtMouseBi - offsetBi; let newEnd = newStart + newSpanBi; let needsAdjustment = false; if (newStart < CUSTOM_TIME_MIN_BI) { newStart = CUSTOM_TIME_MIN_BI; newEnd = newStart + newSpanBi; needsAdjustment = true; } if (newEnd > CUSTOM_TIME_MAX_BI) { newEnd = CUSTOM_TIME_MAX_BI; if (!needsAdjustment) { newStart = newEnd - newSpanBi; } newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart; } if (newStart >= newEnd) { console.warn("Zoom resulted in start >= end."); if (newStart === CUSTOM_TIME_MAX_BI) { newStart = CUSTOM_TIME_MAX_BI - minSpanBi; newEnd = CUSTOM_TIME_MAX_BI; } else { newEnd = newStart + minSpanBi; } newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart; newEnd = newEnd > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : newEnd; } interval.start = newStart; interval.end = newEnd; redraw();
    }

    // --- Initialization ---
    window.addEventListener('resize', handleResize);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('wheel', handleWheel);
    handleResize(); // Initial setup and draw
</script>

</body>
</html>
