<!DOCTYPE html>
<html>
<head>
<!-- ✅ Added Viewport Meta Tag for Mobile -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>BigInt Timeline OOP (Universe Epoch, Cyclical Date) - Dynamic Now</title>
<style>
  /* ✅ Added CSS to prevent default touch behaviors */
  html, body {
    overscroll-behavior: none; /* Prevent pull-to-refresh */
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10+ */
    user-select: none; /* Standard syntax */
    touch-action: none; /* Prevent default touch actions like scroll/zoom on the body */
    height: 100%; /* Needed for 100vh below */
    width: 100%;
  }

  body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    height: 100vh;
    background-color: #f0f0f0; /* Match canvas background */
  }

  canvas {
    display: block;
    background-color: #f0f0f0;
    cursor: crosshair;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    touch-action: none; /* Specifically disable default actions on canvas */
  }

  .title-banner {
    margin-top: 10px;
    font-size: 20px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px 16px;
    border-radius: 8px;
    user-select: none;
    z-index: 2;
  }

  .info {
    position: absolute;
    top: 60px;
    left: 10px;
    background: rgba(255, 255, 255, 0.8);
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 12px;
    user-select: text;
    z-index: 2;
    /* Make info box non-interactive to touches passing through to canvas */
    pointer-events: none;
  }

  .info span {
    display: block;
  }
</style>

</head>


<body>

  <div class="title-banner">ABB Timeline — After Big Bang Time Explorer</div>

<div class="info" id="info-display">
  <span>Start: <span id="info-start"></span></span>
  <span>End: <span id="info-end"></span></span>
  <span>Cursor: <span id="info-cursor"></span></span>
  <span>Now: <span id="info-now"></span></span>
</div>

<canvas id="timelineCanvas"></canvas>
<script>
    // --- BigInt Constants and Time Scale ---
    const SCALING_FACTOR = 10000n;
    const CUSTOM_TIME_MIN_BI = 0n;
    const YEARS_AGO_EPOCH = 13800000000n; // Approx. age for historical calculations
    const MAX_YEARS_FROM_EPOCH = 150000000000n;
    const CUSTOM_TIME_MAX_BI = MAX_YEARS_FROM_EPOCH * SCALING_FACTOR;

    const MS_PER_SECOND_BI = 1000n;
    const SECONDS_PER_MINUTE_BI = 60n;
    const MINUTES_PER_HOUR_BI = 60n;
    const HOURS_PER_DAY_BI = 24n;
    const DAYS_PER_YEAR_APPROX_BI = 3652425n;
    const MS_PER_YEAR_BI = (MS_PER_SECOND_BI * SECONDS_PER_MINUTE_BI * MINUTES_PER_HOUR_BI * HOURS_PER_DAY_BI * DAYS_PER_YEAR_APPROX_BI) / 10000n;

    // --- Configuration & State ---
    const canvas = document.getElementById('timelineCanvas');
    const ctx = canvas.getContext('2d');
    const infoStartEl = document.getElementById('info-start');
    const infoEndEl = document.getElementById('info-end');
    const infoCursorEl = document.getElementById('info-cursor');
    const infoNowEl = document.getElementById('info-now');

    // --- BigInt Time Conversion Functions ---
    function dateToCustomBi(date) { /* ... as before ... */
        if (!date || isNaN(date.getTime())) { try { date = new Date(); } catch { return YEARS_AGO_EPOCH * SCALING_FACTOR; } }
        try { const referenceTbi = YEARS_AGO_EPOCH * SCALING_FACTOR; const referenceDate = new Date(); const targetMs = BigInt(date.getTime()); const referenceMs = BigInt(referenceDate.getTime()); const msDifference = targetMs - referenceMs; let tBiDifference = 0n; if (MS_PER_YEAR_BI > 0n) { tBiDifference = (msDifference * SCALING_FACTOR) / MS_PER_YEAR_BI; } let t = referenceTbi + tBiDifference; t = t < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : t; t = t > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : t; return t; } catch (e) { console.error("Error in dateToCustomBi:", e); return YEARS_AGO_EPOCH * SCALING_FACTOR; }
    }
    function customBiToDate(tBi) { /* ... as before ... */
        if (typeof tBi !== 'bigint') return new Date(NaN);
        try { const referenceTbi = YEARS_AGO_EPOCH * SCALING_FACTOR; const referenceDate = new Date(); const tBiDifference = tBi - referenceTbi; let msDifference = 0n; if (SCALING_FACTOR > 0n) { msDifference = (tBiDifference * MS_PER_YEAR_BI) / SCALING_FACTOR; } const referenceMs = BigInt(referenceDate.getTime()); const targetMs = referenceMs + msDifference; const MAX_SAFE_MS_NUM = 8.64e15; const MIN_SAFE_MS_NUM = -8.64e15; if (targetMs > BigInt(MAX_SAFE_MS_NUM) || targetMs < BigInt(MIN_SAFE_MS_NUM)) { return new Date(NaN); } const targetMsNum = Number(targetMs); const calculatedDate = new Date(targetMsNum); if (isNaN(calculatedDate.getTime())) { return new Date(NaN); } return calculatedDate; } catch (e) { console.error("Error in customBiToDate:", e); return new Date(NaN); }
    }
    function getAstronomicalYear(tBi) { /* ... as before ... */
         if (typeof tBi !== 'bigint' || tBi < 0n) { return null; } if (tBi === 0n) return 1n; return tBi / SCALING_FACTOR + 1n;
    }
    function getDateTimeStringFromTbi(tBi) { /* ... as before ... */
        if (typeof tBi !== 'bigint') return "Invalid"; const astronomicalYearBi = getAstronomicalYear(tBi); if (astronomicalYearBi === null) return "Invalid Year"; const displayYearStr = astronomicalYearBi.toLocaleString(); const fractionalUnitsBi = tBi % SCALING_FACTOR; let msFractionalBi = 0n; if (SCALING_FACTOR > 0n && MS_PER_YEAR_BI > 0n) { msFractionalBi = (fractionalUnitsBi * MS_PER_YEAR_BI) / SCALING_FACTOR; } else { return `${displayYearStr}-??-?? ??:??:?? ABB (Calc Error)`; } const baseYearStartMs = Date.UTC(2000, 0, 1, 0, 0, 0, 0); const msFractionalNum = Number(msFractionalBi); if (!Number.isSafeInteger(msFractionalNum)) { return `${displayYearStr}-??-?? ??:??:?? ABB (Unsafe Fraction)`; } const representativeDate = new Date(baseYearStartMs + msFractionalNum); if (isNaN(representativeDate.getTime())) { return `${displayYearStr}-??-?? ??:??:?? ABB (Date Error)`; } const month = (representativeDate.getUTCMonth() + 1).toString().padStart(2, '0'); const day = representativeDate.getUTCDate().toString().padStart(2, '0'); const hours = representativeDate.getUTCHours().toString().padStart(2, '0'); const minutes = representativeDate.getUTCMinutes().toString().padStart(2, '0'); const seconds = representativeDate.getUTCSeconds().toString().padStart(2, '0'); return `${displayYearStr}-${month}-${day} ${hours}:${minutes}:${seconds} ABB`;
    }
    function formatTimeBiLabel(tBi) { /* ... as before ... */
         if (typeof tBi !== 'bigint') return "Invalid"; let absValue = tBi < 0n ? -tBi : tBi; const sign = tBi < 0n ? "-" : ""; let intPart = absValue / SCALING_FACTOR; let fracPart = absValue % SCALING_FACTOR; let intPartStr = intPart.toLocaleString(); if (fracPart === 0n) { return sign + intPartStr; } else { let fracPartStr = fracPart.toString().padStart(SCALING_FACTOR.toString().length -1, '0'); fracPartStr = fracPartStr.replace(/0+$/, ''); return sign + intPartStr + (fracPartStr.length > 0 ? "." + fracPartStr : ""); }
    }
    function timeBiToX(tBi) { /* ... as before ... */
        const spanBI = interval.end - interval.start; if (spanBI <= 0n) return ctx.canvas.width * 0.1; let timeVal = typeof tBi === 'bigint' ? tBi : interval.start; const clamped_t = timeVal < interval.start ? interval.start : (timeVal > interval.end ? interval.end : timeVal); const numerator = Number(clamped_t - interval.start); const denominator = Number(spanBI); if (denominator === 0) return ctx.canvas.width * 0.1; const ratio = numerator / denominator; const rulerMargin = ctx.canvas.width * 0.1; const rulerWidth = ctx.canvas.width * 0.8; const xPos = rulerMargin + rulerWidth * ratio; return isFinite(xPos) ? xPos : rulerMargin;
    }
    function xToTimeBi(x) { /* ... as before ... */
        const canvasWidth = ctx.canvas.width; const rulerMargin = canvasWidth * 0.1; const rulerWidth = canvasWidth * 0.8; const rulerEnd = rulerMargin + rulerWidth; const clamped_x = Math.max(rulerMargin, Math.min(rulerEnd, x)); if (rulerWidth <= 0) return interval.start; // Avoid division by zero if ruler has no width
        const ratio = (clamped_x - rulerMargin) / rulerWidth; if (!isFinite(ratio)) return interval.start; const spanBI = interval.end - interval.start; const offsetNum = Number(spanBI) * ratio; if (!isFinite(offsetNum)) return interval.start; // Avoid NaN offset
        const offsetBI = BigInt(Math.round(offsetNum)); let calculatedTimeBI = interval.start + offsetBI; calculatedTimeBI = calculatedTimeBI < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : calculatedTimeBI; calculatedTimeBI = calculatedTimeBI > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : calculatedTimeBI; return calculatedTimeBI;
    }
     function calculateNiceTickSpacingBi(spanBi) { /* ... as before ... */
        if (spanBi <= 0n) return { major: 1n * SCALING_FACTOR, minor: (1n * SCALING_FACTOR) / 10n || 1n }; const targetMajorTicks = 10.0; const idealMajorSpacingNum = Number(spanBi) / targetMajorTicks; if (idealMajorSpacingNum <= 0 || !isFinite(idealMajorSpacingNum)) { let fallbackMajor = spanBi / 5n || 1n; fallbackMajor = fallbackMajor > 0n ? fallbackMajor : 1n; let fallbackMinor = fallbackMajor / 10n || 1n; fallbackMinor = fallbackMinor > 0n ? fallbackMinor : 1n; return { major: fallbackMajor, minor: fallbackMinor }; } const magnitudeNum = Math.pow(10, Math.floor(Math.log10(idealMajorSpacingNum))); const residual = idealMajorSpacingNum / magnitudeNum; let niceMultiplierNum; if (residual <= 1.5) niceMultiplierNum = 1; else if (residual <= 3.5) niceMultiplierNum = 2; else if (residual <= 7.5) niceMultiplierNum = 5; else niceMultiplierNum = 10; let majorSpacingBi = BigInt(Math.max(1, Math.round(niceMultiplierNum * magnitudeNum))); majorSpacingBi = majorSpacingBi > 0n ? majorSpacingBi : 1n; let minorSpacingBi = majorSpacingBi / 10n; minorSpacingBi = minorSpacingBi > 0n ? minorSpacingBi : 1n; return { major: majorSpacingBi, minor: minorSpacingBi };
    }

    // --- Timeline Element Classes ---
    class TimelineElement { /* ... as before ... */
        constructor(label, startTbi, endTbi, color) { this.label = label; this.startTbi = startTbi; this.endTbi = endTbi; this.color = color || '#888888'; this.height = 8; }
        isVisible(interval) { return this.endTbi >= interval.start && this.startTbi <= interval.end; }
        draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) { if (!this.isVisible(interval)) { return; } const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); if (endX > startX && endX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; if (drawWidth > 0) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center'; const labelX = drawStartX + drawWidth / 2; if (drawWidth > ctx.measureText(this.label).width * 0.8) { ctx.fillText(this.label, labelX, yPos - 2); } else if (startX >= rulerMargin && startX <= rulerEnd) { ctx.fillText(this.label, startX + 3, yPos - 2); } } } else if (endX === startX && startX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(startX, yPos); ctx.lineTo(startX - 3, yPos + this.height); ctx.lineTo(startX + 3, yPos + this.height); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(this.label, startX, yPos - 2); } }
    }
    class SunElement extends TimelineElement { /* ... as before ... */
        constructor(startYearABB, endYearABB) { const startTbi = startYearABB * SCALING_FACTOR; const endTbi = endYearABB * SCALING_FACTOR; super('☉ Sun (Main Sequence)', startTbi, endTbi, 'rgba(255, 165, 0, 0.7)'); this.height = 10; }
        draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) { if (!this.isVisible(interval)) return; const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); if (endX > startX && endX >= rulerMargin && startX <= rulerEnd) { ctx.fillStyle = this.color; const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; if (drawWidth > 0) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); ctx.fillStyle = '#cc8400'; ctx.font = '9px sans-serif'; const labelOffset = this.height + 2; if (startX >= rulerMargin - 5 && startX <= rulerEnd + 5) { ctx.textAlign = 'center'; ctx.fillText('Start', startX, yPos - 2); } if (endX >= rulerMargin - 5 && endX <= rulerEnd + 5) { ctx.textAlign = 'center'; ctx.fillText('End', endX, yPos - 2); } ctx.fillStyle = '#000'; ctx.textAlign = 'center'; const labelX = drawStartX + drawWidth / 2; if (drawWidth > ctx.measureText(this.label).width * 0.8) { ctx.fillText(this.label, labelX, yPos + this.height + 10); } } } }
    }
    class DinosaurElement extends TimelineElement { /* ... as before ... */
         constructor(startYearsAgo, endYearsAgo) { const startYearABB = YEARS_AGO_EPOCH - startYearsAgo; const endYearABB = YEARS_AGO_EPOCH - endYearsAgo; const startTbi = startYearABB * SCALING_FACTOR; const endTbi = endYearABB * SCALING_FACTOR; super('Dinosaurs (Mesozoic Era)', startTbi, endTbi, 'rgba(0, 128, 0, 0.7)'); this.height = 6; }
    }
    class HumanElement extends TimelineElement { /* ... as before ... */
         constructor(startYearsAgo) { const startYearABB = YEARS_AGO_EPOCH - startYearsAgo; const endYearABB = YEARS_AGO_EPOCH; /* Ends 'now' */ const startTbi = startYearABB * SCALING_FACTOR; /* Dynamic end below */ super('Humans (Homo Sapiens)', startTbi, 0n /* Placeholder end */, 'rgba(0, 0, 255, 0.7)'); this.height = 4; } // EndTbi will be set dynamically
         draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd) {
              this.endTbi = dateToCustomBi(new Date()); // ✅ Set dynamic end time here!
              if (!this.isVisible(interval)) return;
              const startX = timeBiToX(this.startTbi); const endX = timeBiToX(this.endTbi); // Use dynamic endX
              if (endX >= rulerMargin && startX <= rulerEnd) { const drawStartX = Math.max(startX, rulerMargin); const drawEndX = Math.min(endX, rulerEnd); const drawWidth = drawEndX - drawStartX; ctx.fillStyle = this.color; if (drawWidth >= 1) { ctx.fillRect(drawStartX, yPos, drawWidth, this.height); } else if (startX >= rulerMargin && startX <= rulerEnd) { ctx.lineWidth = 1.5; ctx.strokeStyle = this.color; ctx.beginPath(); ctx.moveTo(startX, yPos - 2); ctx.lineTo(startX, yPos + this.height + 2); ctx.stroke(); } if (startX >= rulerMargin - 5 && startX <= rulerEnd + 5) { ctx.fillStyle = '#000'; ctx.font = '9px sans-serif'; ctx.textAlign = 'left'; ctx.fillText(this.label, startX + 4, yPos + this.height / 2 + 3); } }
         }
    }
    class TimelineManager { /* ... as before ... */
        constructor(rulerY, verticalSpacing) { this.elements = []; this.rulerY = rulerY; this.verticalSpacing = verticalSpacing; }
        addElement(element) { if (element instanceof TimelineElement) { this.elements.push(element); } else { console.warn("Attempted to add non-TimelineElement object:", element); } }
        drawElements(ctx, interval, timeBiToX, rulerMargin, rulerEnd) { this.elements.forEach((element, index) => { const yPos = this.rulerY - (index + 1) * this.verticalSpacing - element.height; try { element.draw(ctx, interval, timeBiToX, yPos, rulerMargin, rulerEnd); } catch (e) { console.error("Error drawing element:", element.label, e); } }); }
    }


    // --- Initial State Setup ---
    const initialNowBi = dateToCustomBi(new Date());
    const initialSpanYears = 100n; // Initial view span
    const initialSpanBI = initialSpanYears * SCALING_FACTOR;

    let interval = { /* ... as before ... */
        start: initialNowBi - initialSpanBI / 2n, end:   initialNowBi + initialSpanBI / 2n, now:   initialNowBi, cursor: -1n
    };
    // Clamp initial interval...
    interval.start = interval.start < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : interval.start; interval.end = interval.end > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : interval.end; if (interval.start >= interval.end) { interval.start = interval.end - initialSpanBI; interval.start = interval.start < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : interval.start; if (interval.start >= interval.end) { interval.end = interval.start + initialSpanBI; interval.end = interval.end > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : interval.end; } }
     // Ensure initial 'now' is within the calculated initial view
    interval.now = interval.now < interval.start ? interval.start : interval.now; interval.now = interval.now > interval.end ? interval.end : interval.now;


    let pos = { x: 0, y: 0 };

    // --- ✅ TOUCH STATE VARIABLES ---
    let isTouching = false;
    let isPinching = false;
    let isPanning = false;
    let initialPinchDistance = 0;
    let touchPoints = []; // Stores active touch points: {id, x, y, initialX, initialY}
    let panStartX = 0; // Initial X of the panning finger
    let panIntervalStartInitial = 0n; // interval.start when panning began
    let touchStartTime = 0; // Timestamp of touchstart
    const TAP_THRESHOLD_MS = 250; // Max duration for a tap (milliseconds)
    const TAP_THRESHOLD_PX = 10; // Max movement distance for a tap (pixels)


    // --- Create and Populate Timeline Manager ---
    const SUN_START_YEAR_ABB = YEARS_AGO_EPOCH - 4600000000n;
    const SUN_END_YEAR_ABB = YEARS_AGO_EPOCH + 5000000000n;
    const DINO_START_YEARS_AGO = 245000000n;
    const DINO_END_YEARS_AGO = 66000000n;
    const HUMAN_START_YEARS_AGO = 300000n; // Homo Sapiens start

    const timelineManager = new TimelineManager(canvas.height * 0.5, 15); // Ruler Y, Spacing

    timelineManager.addElement(new SunElement(SUN_START_YEAR_ABB, SUN_END_YEAR_ABB));
    timelineManager.addElement(new DinosaurElement(DINO_START_YEARS_AGO, DINO_END_YEARS_AGO));
    timelineManager.addElement(new HumanElement(HUMAN_START_YEARS_AGO)); // End time is dynamic now


    // --- Drawing Function ---
    function drawRuler() { /* ... as before ... */
        const canvasWidth = ctx.canvas.width; const canvasHeight = ctx.canvas.height; const rulerY = canvasHeight * 0.5; const rulerMargin = canvasWidth * 0.1; const rulerWidth = canvasWidth * 0.8; const rulerEnd = rulerMargin + rulerWidth;
        timelineManager.rulerY = rulerY; ctx.clearRect(0, 0, canvasWidth, canvasHeight); ctx.lineWidth = 2; ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(rulerMargin, rulerY); ctx.lineTo(rulerEnd, rulerY); ctx.stroke();
        const spanBI = interval.end - interval.start; let currentMajorSpacingBi = 0n; let currentMinorSpacingBi = 0n; if (spanBI > 0n) { const spacing = calculateNiceTickSpacingBi(spanBI); currentMajorSpacingBi = spacing.major; currentMinorSpacingBi = spacing.minor; } else { currentMajorSpacingBi = 1n * SCALING_FACTOR; currentMinorSpacingBi = currentMajorSpacingBi / 10n || 1n; }
        if (currentMinorSpacingBi > 0n && currentMajorSpacingBi > 0n) { let remainder = interval.start % currentMinorSpacingBi; if (remainder < 0n) { remainder += currentMinorSpacingBi; } let firstTickTimeBi = interval.start - remainder + (remainder === 0n ? 0n : currentMinorSpacingBi); if (firstTickTimeBi < interval.start) { firstTickTimeBi += currentMinorSpacingBi; } ctx.lineWidth = 1; ctx.strokeStyle = '#666'; ctx.fillStyle = '#333'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; for (let tBi = firstTickTimeBi; tBi <= interval.end + currentMinorSpacingBi; tBi += currentMinorSpacingBi) { if (tBi < interval.start - currentMinorSpacingBi) continue; const x = timeBiToX(tBi); if (x < rulerMargin - 10 || x > rulerEnd + 10) continue; let isMajorTick = false; try { isMajorTick = (tBi % currentMajorSpacingBi === 0n); } catch {} ctx.beginPath(); ctx.moveTo(x, rulerY - (isMajorTick ? 8 : 4)); ctx.lineTo(x, rulerY + (isMajorTick ? 8 : 4)); ctx.stroke(); if (isMajorTick) { if (x >= rulerMargin - 0.1 && x <= rulerEnd + 0.1) { const label = formatTimeBiLabel(tBi); ctx.fillText(label, x, rulerY + 20); } } } } else { console.warn("Final tick spacing invalid or zero span."); }
        timelineManager.drawElements(ctx, interval, timeBiToX, rulerMargin, rulerEnd);
        interval.now = dateToCustomBi(new Date()); const nowTbiClampedForDraw = interval.now < interval.start ? interval.start : (interval.now > interval.end ? interval.end : interval.now); if (interval.now >= interval.start && interval.now <= interval.end) { const nowX = timeBiToX(interval.now); if (isFinite(nowX)) { ctx.lineWidth = 1.5; ctx.strokeStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(nowX, rulerY - 15); ctx.lineTo(nowX, rulerY + 15); ctx.stroke(); ctx.fillStyle = '#ff0000'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('Now', nowX, rulerY - 18); } }
        if (interval.cursor >= CUSTOM_TIME_MIN_BI && interval.cursor >= interval.start && interval.cursor <= interval.end) { const cursorX = timeBiToX(interval.cursor); if (isFinite(cursorX)) { ctx.lineWidth = 1.5; ctx.strokeStyle = '#00cc00'; ctx.beginPath(); ctx.moveTo(cursorX, rulerY - 12); ctx.lineTo(cursorX, rulerY + 12); ctx.stroke(); ctx.fillStyle = '#00cc00'; ctx.beginPath(); ctx.moveTo(cursorX - 4, rulerY - 12); ctx.lineTo(cursorX + 4, rulerY - 12); ctx.lineTo(cursorX, rulerY - 18); ctx.closePath(); ctx.fill(); } }
        infoStartEl.textContent = `${getDateTimeStringFromTbi(interval.start)} (t=${formatTimeBiLabel(interval.start)})`; infoEndEl.textContent = `${getDateTimeStringFromTbi(interval.end)} (t=${formatTimeBiLabel(interval.end)})`; infoCursorEl.textContent = interval.cursor < CUSTOM_TIME_MIN_BI ? 'N/A' : `${getDateTimeStringFromTbi(interval.cursor)} (t=${formatTimeBiLabel(interval.cursor)})`; infoNowEl.textContent = `${getDateTimeStringFromTbi(interval.now)} (t=${formatTimeBiLabel(interval.now)})`;
    } // End drawRuler

    function redraw() { requestAnimationFrame(drawRuler); }

    // --- Helper: Clamp Function ---
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

     // --- Helper: Calculate Distance ---
     function getDistance(p1, p2) {
         const dx = p1.x - p2.x;
         const dy = p1.y - p2.y;
         return Math.sqrt(dx * dx + dy * dy);
     }


     // --- EVENT HANDLERS ---

     function handleResize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; redraw(); }
     function handleMouseMove(event) { pos.x = event.clientX; pos.y = event.clientY; } // For potential desktop features

     // --- MOUSE Interaction Handlers ---
     // --- MOUSE Interaction Handlers ---

     function handleMouseDown(event) {
         // Ignore right clicks or if a touch interaction is already happening
         if (event.button !== 0 || isTouching) return;
         pos.x = event.clientX; pos.y = event.clientY;
         const rulerY = canvas.height * 0.5;
         // Set cursor only if clicking near the ruler vertically
         if (Math.abs(pos.y - rulerY) < 50) { // Generous click tolerance on Y axis
             interval.cursor = xToTimeBi(pos.x);
             console.log("Cursor set (mouse):", interval.cursor.toString(), " -> ", getDateTimeStringFromTbi(interval.cursor));
             redraw();
         }
     }

     // ✅ CORRECTED: Mouse Wheel handler with original boundary checks restored
     function handleWheel(event) {
        // Prevent default page scroll only if wheel event is on the canvas
        if (event.target === canvas) {
            event.preventDefault();
        } else {
            return; // Don't handle wheel events outside the canvas
        }

        const scrollDelta = event.deltaY;
        const isZoomingIn = scrollDelta < 0; // True if scrolling up/zooming in
        const zoomFactor = isZoomingIn ? 0.80 : 1.20;

        const currentSpanBi = interval.end - interval.start;
        const minSpanBi = 10n; // Minimum span in tBi units
        const maxPossibleSpan = CUSTOM_TIME_MAX_BI - CUSTOM_TIME_MIN_BI;

        // --- Boundary Checks ---
        // Stop zooming IN further if already at minimum span
        if (isZoomingIn && currentSpanBi <= minSpanBi) {
            // console.log("Wheel: Min zoom reached.");
            return;
        }
        // Stop zooming OUT further if already at maximum span
        if (!isZoomingIn && currentSpanBi >= maxPossibleSpan) {
            // console.log("Wheel: Max zoom reached.");
            return;
        }
        // --- End Boundary Checks ---


        const timeAtMouseBi = xToTimeBi(event.clientX); // Zoom centered on mouse pointer

        // Calculate new span
        let newSpanNum = Number(currentSpanBi) * zoomFactor;
        let newSpanBi = BigInt(Math.max(1, Math.round(newSpanNum))); // Ensure span > 0

        // Clamp the *calculated* span immediately AFTER calculation,
        // BEFORE using it to find start/end. This prevents edge cases where
        // float math might make it slightly exceed bounds before the check above.
        newSpanBi = newSpanBi < minSpanBi ? minSpanBi : newSpanBi;
        newSpanBi = newSpanBi > maxPossibleSpan ? maxPossibleSpan : newSpanBi;


        // Determine the ratio of the mouse pointer's position within the current span
        let ratio = 0.5; // Default to center if span is zero or calculation fails
        if (currentSpanBi > 0n) {
            const mouseOffsetNum = Number(timeAtMouseBi - interval.start);
            const currentSpanNum = Number(currentSpanBi);
            if (currentSpanNum !== 0 && isFinite(mouseOffsetNum)) {
                ratio = mouseOffsetNum / currentSpanNum;
                ratio = clamp(ratio, 0, 1); // Clamp ratio between 0 and 1 (using helper)
            }
        }

        // Calculate the new start time based on keeping the time under the mouse pointer fixed
        const offsetNum = Number(newSpanBi) * ratio;
        if (!isFinite(offsetNum)) { console.warn("Invalid offset in wheel zoom"); return; } // Avoid NaN
        const offsetBi = BigInt(Math.round(offsetNum));

        let newStart = timeAtMouseBi - offsetBi;
        let newEnd = newStart + newSpanBi;

        // --- Enforce Absolute Bounds for start/end (Final clamping) ---
         let needsAdjustment = false;
         if (newStart < CUSTOM_TIME_MIN_BI) { newStart = CUSTOM_TIME_MIN_BI; newEnd = newStart + newSpanBi; needsAdjustment = true; }
         // Check end bound AFTER potential start adjustment
         if (newEnd > CUSTOM_TIME_MAX_BI) {
             newEnd = CUSTOM_TIME_MAX_BI;
             // Adjust start only if end clamp was the only adjustment needed
             if (!needsAdjustment) { newStart = newEnd - newSpanBi; }
             // Re-clamp start just in case
             newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart;
         }
         // Final check: ensure start < end after all clamping
         if (newStart >= newEnd) {
             console.warn("Wheel Zoom resulted in start >= end after clamping. Adjusting.");
             // Attempt to recover based on which boundary might be causing issue
             if (newEnd <= CUSTOM_TIME_MIN_BI + minSpanBi) { // If stuck near min
                 newStart = CUSTOM_TIME_MIN_BI;
                 newEnd = newStart + minSpanBi;
             } else { // Otherwise assume stuck near max or other issue
                 newStart = newEnd - minSpanBi;
             }
              // Final re-clamp after recovery attempt
              newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart;
              newEnd = newEnd > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : newEnd;
         }


        interval.start = newStart;
        interval.end = newEnd;
        redraw(); // Redraw with the new interval
     }

    // --- ✅ Need Clamp Helper ---
    function clamp(value, min, max) {
        // Ensure min <= max before clamping
        if (min > max) { [min, max] = [max, min]; } // Swap if min > max
        return Math.max(min, Math.min(max, value));
    }

    // --- ✅ TOUCH EVENT HANDLERS ---
    // (Keep the touch handlers as they were in the previous version)
    function handleTouchStart(event) { /* ... Touch code from previous step ... */
        if (event.target === canvas) { event.preventDefault(); } else { return; }
        isTouching = true; isPanning = false; isPinching = false;
        touchPoints = Array.from(event.touches).map(t => ({ id: t.identifier, x: t.clientX, y: t.clientY, initialX: t.clientX, initialY: t.clientY }));
        touchStartTime = performance.now();
        if (touchPoints.length === 1) { isPanning = true; panStartX = touchPoints[0].x; panIntervalStartInitial = interval.start; } else if (touchPoints.length === 2) { isPanning = false; isPinching = true; initialPinchDistance = getDistance(touchPoints[0], touchPoints[1]); } else { isPanning = false; isPinching = false; }
    }
    function handleTouchMove(event) { /* ... Touch code from previous step ... */
        if (!isTouching) return; if (event.target === canvas) { event.preventDefault(); } else { return; }
        const currentTouches = Array.from(event.touches); let activeTouchCount = 0;
        touchPoints.forEach(tp => { const current = currentTouches.find(ct => ct.identifier === tp.id); if (current) { tp.x = current.clientX; tp.y = current.clientY; activeTouchCount++; } });
        touchPoints = touchPoints.filter(tp => currentTouches.some(ct => ct.identifier === tp.id));
        if (isPinching && touchPoints.length < 2) { isPinching = false; if (touchPoints.length === 1) { isPanning = true; panStartX = touchPoints[0].x; panIntervalStartInitial = interval.start; touchStartTime = performance.now(); } }
        if (isPanning && touchPoints.length !== 1) { isPanning = false; if (touchPoints.length === 2) { isPinching = true; initialPinchDistance = getDistance(touchPoints[0], touchPoints[1]); } }
        if (isPinching && touchPoints.length === 2) { const currentDistance = getDistance(touchPoints[0], touchPoints[1]); if (initialPinchDistance > 1 && currentDistance > 1) { const zoomFactor = initialPinchDistance / currentDistance; const pinchCenterX = (touchPoints[0].x + touchPoints[1].x) / 2; const timeAtPinchCenterBi = xToTimeBi(pinchCenterX); const currentSpanBi = interval.end - interval.start; const minSpanBi = 10n; const maxPossibleSpan = CUSTOM_TIME_MAX_BI - CUSTOM_TIME_MIN_BI; let newSpanNum = Number(currentSpanBi) * zoomFactor; let newSpanBi = BigInt(Math.max(1, Math.round(newSpanNum))); newSpanBi = newSpanBi > minSpanBi ? newSpanBi : minSpanBi; newSpanBi = newSpanBi > maxPossibleSpan ? maxPossibleSpan : newSpanBi; if (newSpanBi !== currentSpanBi) { let ratio = 0.5; if (currentSpanBi > 0n) { const centerOffsetNum = Number(timeAtPinchCenterBi - interval.start); const currentSpanNum = Number(currentSpanBi); if(currentSpanNum !== 0 && isFinite(centerOffsetNum)) { ratio = centerOffsetNum / currentSpanNum; ratio = clamp(ratio, 0, 1); } } const offsetNum = Number(newSpanBi) * ratio; if (!isFinite(offsetNum)) { console.warn("Invalid offset (pinch)"); return; } const offsetBi = BigInt(Math.round(offsetNum)); let newStart = timeAtPinchCenterBi - offsetBi; let newEnd = newStart + newSpanBi; let needsAdjustment = false; if (newStart < CUSTOM_TIME_MIN_BI) { newStart = CUSTOM_TIME_MIN_BI; newEnd = newStart + newSpanBi; needsAdjustment = true; } if (newEnd > CUSTOM_TIME_MAX_BI) { newEnd = CUSTOM_TIME_MAX_BI; if (!needsAdjustment) { newStart = newEnd - newSpanBi; } newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart; } if (newStart >= newEnd) { console.warn("Pinch Zoom resulted in start >= end. Clamping."); if (newEnd <= CUSTOM_TIME_MIN_BI + minSpanBi) { newStart = CUSTOM_TIME_MIN_BI; newEnd = newStart + minSpanBi; } else { newStart = newEnd - minSpanBi; } newEnd = newEnd > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : newEnd; } interval.start = newStart; interval.end = newEnd; initialPinchDistance = currentDistance; redraw(); } } }
        else if (isPanning && touchPoints.length === 1) { const currentX = touchPoints[0].x; const deltaX = currentX - panStartX; const canvasWidth = ctx.canvas.width; const rulerWidth = canvasWidth * 0.8; const currentSpanBi = interval.end - interval.start; if (rulerWidth > 0 && currentSpanBi > 0n) { const tBiPerPixelNum = Number(currentSpanBi) / rulerWidth; if (!isFinite(tBiPerPixelNum)) { console.warn("Invalid tBiPerPixel"); return; } const deltaTbi = BigInt(Math.round(tBiPerPixelNum * deltaX)); let newStart = panIntervalStartInitial - deltaTbi; let newEnd = newStart + currentSpanBi; if (newStart < CUSTOM_TIME_MIN_BI) { newStart = CUSTOM_TIME_MIN_BI; newEnd = newStart + currentSpanBi; } if (newEnd > CUSTOM_TIME_MAX_BI) { newEnd = CUSTOM_TIME_MAX_BI; newStart = newEnd - currentSpanBi; } newStart = newStart < CUSTOM_TIME_MIN_BI ? CUSTOM_TIME_MIN_BI : newStart; newEnd = newEnd > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : newEnd; if (newStart >= newEnd) { console.warn("Pan resulted in invalid interval"); if(newStart === CUSTOM_TIME_MIN_BI) newEnd = newStart + minSpanBi; else if(newEnd === CUSTOM_TIME_MAX_BI) newStart = newEnd - minSpanBi; else { newStart = interval.start; newEnd = interval.end; } newEnd = newEnd > CUSTOM_TIME_MAX_BI ? CUSTOM_TIME_MAX_BI : newEnd; } interval.start = newStart; interval.end = newEnd; redraw(); } }
    }
    function handleTouchEnd(event) { /* ... Touch code from previous step ... */
        if (!isTouching) return; const changedTouchesOnCanvas = Array.from(event.changedTouches).some(ct => touchPoints.some(tp => tp.id === ct.identifier)); if (changedTouchesOnCanvas && event.target === canvas) { event.preventDefault(); }
        const touchDuration = performance.now() - touchStartTime; const liftedTouches = Array.from(event.changedTouches);
        liftedTouches.forEach(lt => { const liftedPoint = touchPoints.find(tp => tp.id === lt.identifier); if (liftedPoint && isPanning && touchPoints.length === 1) { const deltaX = lt.clientX - liftedPoint.initialX; const deltaY = lt.clientY - liftedPoint.initialY; const distanceMoved = Math.sqrt(deltaX * deltaX + deltaY * deltaY); if (touchDuration < TAP_THRESHOLD_MS && distanceMoved < TAP_THRESHOLD_PX) { const rulerY = canvas.height * 0.5; if (Math.abs(lt.clientY - rulerY) < 50) { interval.cursor = xToTimeBi(lt.clientX); console.log("Cursor set (tap):", interval.cursor.toString(), " -> ", getDateTimeStringFromTbi(interval.cursor)); redraw(); } } } });
        touchPoints = touchPoints.filter(tp => !liftedTouches.some(lt => lt.identifier === tp.id));
        if (touchPoints.length === 0) { isTouching = false; isPanning = false; isPinching = false; } else if (touchPoints.length === 1) { isPinching = false; isPanning = true; panStartX = touchPoints[0].x; panIntervalStartInitial = interval.start; touchStartTime = performance.now(); } else if (touchPoints.length >= 2) { if (touchPoints.length === 2) { isPanning = false; isPinching = true; initialPinchDistance = getDistance(touchPoints[0], touchPoints[1]); } else { isPanning = false; isPinching = false; } }
    }
    function handleTouchCancel(event) { /* ... Touch code from previous step ... */
         touchPoints = []; isTouching = false; isPanning = false; isPinching = false;
    }

     // --- Helper: Calculate Distance ---
     function getDistance(p1, p2) { /* ... Touch code from previous step ... */
         const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.sqrt(dx * dx + dy * dy);
     }

    // --- Initialization ---
    window.addEventListener('resize', handleResize);

    // Mouse Listeners
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('wheel', handleWheel, { passive: false }); // Keep passive:false

    // Touch Listeners
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleTouchCancel);


    handleResize(); // Initial setup and draw
</script>

</body>
</html>
